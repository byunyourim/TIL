https://school.programmers.co.kr/learn/courses/30/lessons/154539

## 1. 문제 이해하기



<br><br><br>

## 2. 재정의
자신보다 뒤에 있는 숫자들 중에서
1. 자신보다 크고 가장 가까이에 있는 수를 출력한다.
2. 자신보다 큰 수가 없는 경우 -1을 출력한다.


<br><br><br>

## 3. 알고리즘 
중첩 for문을 사용
그리고 뒤에 있는 숫자들과 비교한다. 큰 수를 다시 배열로 만든다  
 
시간 복잡도 : O(N^2)


하지만 시간복잡도가 매우 크다.



<br><br><br>

## 4. 의사코드
```
max = 자신보다 뒤에있는 큰 수
res[] = 결과 배열을 생성한다.
for (numbers 배열을 순회한다 : i) {
    for ( j : i 뒤 인덱스) {
        numbers[i]와 그 뒤에 있는 numbers[j]들과 비교한다.
        뒤에 수가 없는 경우 max는 -1이다.
        if (numbers[i] < numbers[j]) {
            max = numbers[j];
            break;
        } else {
            continue;
        }
        max = -1;
    }
    res[i] = max;
}
```


<br><br><br>

## 5. 구현


## 6. 리팩토링
시간 초과로 테스트를 통과하지 못했다..

  
위의 방법은 시간 복잡도가 매우 크다

그래서 스택을 사용한 방법으로 수정해보았다.
배열을 역순으로 탐색해보자.

for (numbers 거꾸로) :

  스택에서 현재 값보다 작은 값들을 모두 제거

  스택이 비어있으면 더 큰 수가 없다는 의미로 -1을 저장

  현재 숫자를 배열에 추가

