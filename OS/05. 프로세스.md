# Process

디스크에서 메모리로 올라와 실행 중인 프로그램
    
운영체제에서 자원을 할당 받아 CPU에서 실행되고 있는 프로그램   
    
하나의 프로세스는 하나의 이상의 Task로 구성되며, 운영체제는 각 프로세스를 태스크로 관리하며, 실행에 필요한 자원을
할당하고 상태를 관리한다.    

일반적으로 프로세스는 여러 개의 스레드로 구성되는데, 각 스레드가 독립적으로 실행되는 작업 단위의 역할(Task)을 한다.

스레드는 태스크를 실행하기 위한 실행 단위이고, 태스크는 수행해야할 논리적인 작업이다.


CPU가 메모리 위에 있는 프로그램의 명령어를 CPU 내부 레지스터로 가져와 실행한다.  


---
## 프로세스의 구조
<img width="180" alt="image" src="https://github.com/user-attachments/assets/855ac677-1a1e-4f31-8184-24ad40dee939">

스택, 힙, 데이터, 코드로 구성되어 명령을 수행하기 위한 데이터와 상태 정보를 포함한다.
```
- 텍스트 영역 : 실행 가능한 코드가 저장된다.
- 데이터 영역 : 전역변수가 저장된다.
- 힙 영역 : 프로그램 실행동안 동적으로 할당되는 변수가 저장된다.
- 스택 영역 : 호출된 함수, 전달된 인자, 복귀 주소, 지역 변수 등이 저장된다.
```

---

## Process Status
![process_status.png](https://github.com/user-attachments/assets/61b814de-ba75-4f83-bf4d-6b1203d57ac8)

- **New**: 프로세스가 생성된 상태
- **Ready**: 프로세스가 CPU에 실행되기 위해 대기하는 상태로, CPU자원이 할당되지 않은 상태
- **Running**: 프로세스가 CPU를 할당받아 실제로 실행 중인 상태
- **Waiting**: 프로세스가 특정 자원이나 이벤트를 기다리는 상태
- **Terminated**: 프로세스가 실행이 완료되거나 종료된 상태

  #### 상태 전이 동작
    ##### Dispatch
    우선순위가 높은 프로세스를 선정하여 명령어를 실행한다
    ##### Timeout
    클럭이 인터럽트를 발생시켜 제어권을 빼앗는다.(Preemption:독점방지)
    ##### Block
    프로세서가 입출력, 자원 등을 기다리기 위해 대기상태로 전환한다.
    ##### Wake up
    입출력이 완료되거나 자원이 할당되어 다시 실행한다.

---

### Process Control Block
프로세스의 상태 정보를 저장하는 구조로, 각 프로세스는 고유한 PCB를 갖는다. 
운영체제가 해당 PCB를 참조하여 현재 실행 중인 프로세스를 관리하고, 
context switching시 이전의 상태로 돌아갈 수 있도록 한다.

![pcb.png](https://github.com/user-attachments/assets/7b7f92ac-b40c-48a7-889c-b04847a057cc)

- **Process ID** : Process Identification Number, 프로세스 고유 식별 번호로 PID라 한다.
- **Process State** : 프로세스의 현재 상태(생성, 준비, 실행, 대기, 종료)
- **Program Counter** : 메모리의 다음 명령어 주소
- **Process Priority** : 프로세스 우선순위 등스케줄링 관련 정보.
- **CPU Registers** : 프로세스의 레지스터 상태 저장, CPU 내 범용 레지스터, 데이터 레지스터, 세그먼트 레지스터 관련 정보.
- **Owner** : CPU 사용시간 정보(Quantum), 각종 스케줄러에 필요한 정보
- **기억장치 관리 정보** : 프로그램이 적재될 기억 장치의 시작 지점(베이스 레지스터), 종료 지점(한계 레지스터), 페이지 테이블 등.
- **입출력 정보** : 프로세스 수행 시 필요한 주변 장치 및 파일 정보


PCB는 운영체제의 스케줄링에서 관리된다. 이때, Doubly Linked List 방식으로 관리된다. 
   
그 이유는, 주소 값만 조정하면 되므로, 프로세스가 생성되거나 종료될 때 효율적으로 처리할 수 있고, 양방향 탐색이 가능해 삽입과 삭제가 용이하다. 다양한 큐를 관리할 수 있다. 

---

## Process Scheduling

멀티프로그래밍 환경에서 운영체제는 CPU자원을 여러 프로세스가 효율적으로 공유하도록 하기 위해, 스케줄링 알고리즘을 사용하여 CPU를 어느 프로세스에 할당할지 결정한다. 이로 인해 동시에 여러 작업이 이루어지는 것처럼 보인다.   
      
스케줄러가 READY 프로세스 중 하나를 선택하여 CPU를 할당하면, 프로세스가 RUNNING 상태가 된다. 작업을 Terminated, WAITING가 되면  다음 프로세스에 CPU를 할당한다.  
   
프로세스는 CPU에 의해 실행되다가, interrupt()에 의해 작업이 중단되면 wait queue라는 곳에는 저장된다. 
Wait Queue에는 I/O 연산, 이벤트 대기로 인해 READY로 전환된 프로세스들이 저장되는 곳이다. 특정 입출력 장치가 자유로워지면 해당 프로세스가 다시 Ready Queue로 이동한다.

### 스케줄러의 역할
CPU와 시스템 자원을 여러 프로세스에 할당하는 기능을 담당
- 장기 : 메모리에 프로세스를 얼마나 많이 로드할지 결정, 프로세스 생성 시 실행되어, 시스템의 멀티프로그래밍 정도를 제어.
- 중기 : 메모리 부족 시, 실행 중인 프로세스를 Swapping하거나 재개하여 메모리 자원을 관리. 스왑 영역과 메모리 간의 전환 담당
- 단기 : Ready Queue에 있는 프로세스 중 하나를 선택하여 CPU에 할당. 자주 동작하며, CPU가 어떤 프로세스를 실행할지 결정.

### 스케줄링 종류
#### 선점형 스케줄링 Preemptive Scheduling
CPU가 현재 실행 중인 프로세스를 중간에 멈추고 다른 프로세스를 실행할 수 있다.
- 예시: 라운드 로빈(Round Robin), 우선순위 기반 스케줄링(Priority Scheduling)
#### 비선점형 스케줄링 Non-preemptive Scheduling
실행 중인 프로세스가 CPU를 반환하지 않는 한, 다른 프로세스가 CPU를 사용하지 못한다.
- 예시: FCFS(First-Come, First-Served), SJF(Shortest Job First)

### 스케줄링 큐
스케줄링 큐는 링크드 리스트의 구조로 큐의 헤더는 첫 PCB를 가리키며, 각 PCB마다 다음 실행될 PCB를 가리킨다.  
  
메인 메모리에 올라가기 전 프로그램들은 Job Queue에서 대기한다ㅏ.
메인 메모리에 적재되면, ready queue에 올라가서 자원을 할당 받기까지 기다리게 된다. 

반면, *Waiting Queue는 자원이 부족하거나 I/O 작업 등 특정 이벤트를 기다리는 프로세스들이 대기하는 큐로, CPU는 준비되어 있지만, 해당 프로세스는 특정 조건이 충족될 때까지 실행될 수 없는 상태이다.


---

### 문맥 교환 (Context Switching)

CPU가 현재 실행 중인 프로세스의 상태를 저장하고 다른 프로세스의 상태를 가져오는 과정으로 여러 프로세스가 돌아가며 CPU를 사용할 수 있도록하는 작업이다. 

문맥은 운영체제가 프로세스의 실행 상태를 추적하고 관리하기 위해 필요한 정보로, CPU에서 실행되다가 중단 후 재개할 때 이전과 동일한 상태에서 시작할 수 있도록 한다.

#### Process Conext
문맥은 **마지막에 수행했던 명령어의 위치**로 크게 세 가지(**하드웨어 문맥, 프로세스의 주소 공간, 커널 상의 문맥**)로 구성된다.

**하드웨어 문맥**은 CPU 수행 상태를 나타내며, PC와 각종 레지스터에 저장하는 값이다.

**프로세스의 주소 공간**은 코드, 데이터, 스택으로 구성된 프로세스만의 독자적인 주소 공간이다.

**커널상의 문맥**은 프로세스 관리를 위한 PCB와 Kernel stack이다.  
문맥 교환은 한 프로세스의 실행을 중단하고 다른 프로세스를 실행할 때 발생한다. 
  
#### 문맥 교환의 과정
```
1. 현재 실행 중인 프로세스의 문맥 저장
현재 프로세스의 CPU 레지스터 값, 프로그램 카운터, 메모리 상태를 PCB에 저장

2. 다른 프로세스의 문맥 로드
다음에 실행할 프로세스의 PCB에서 문맥 정보를 불러와 CPU 레지스터에 로드한다.

3. 프로세스 실행 재개
로드된 문맥 정보에 따라 새로운 프로세스가 실행한다.
```

문맥은 PCB에 표시되며, 인터럽트가 발생했을 때 운영체제는 현재 수행 중인 프로세스의 문맥을 저장하고, 
후에 다시 프로세스를 수행할 때 저장해둔 문맥을 복구한다.  

문맥 전환은 필수적이지만, 자주 발생하는 경우 오버헤드가 발생한다.

#### Context Switching 발생 시점
- 멀티 태스킹 또는 시분할 시스템에서 할당된 시간이 종료된 경우
- 입출력 또는 시스템 호출
- 우선순위에 따른 프로세스 스케줄링
- 프로세스가 종료되는 경우
- 인터럽트 발생 시
- 자발적인 CPU 양도

---
#### 프로세스와 스레드에서 Conext Switching이 발생 차이
프로세스는 code, data, heap, stack 영역을 독립적으로 갖는다.
Context Swtiching이 발생할 때, 독립적인 메모리를 포함하여, 캐시 메모리를 비워줘야 해서 스레드에 비해 상대적으로 많은 오버헤드가 발생한다.
반면, 스레드는 code, data, heap 영역을 공유하고 stack 영역만 독립적으로 갖는다. 따라서 캐시 메모리를 비우지 않아도 되기 때문에 프로세스에 비해 상대적으로 적은 오버헤드가 발생한다.

---

#### Context Switching 시 캐시 차이
프로세스는 독립적인 메모리 공간을 갖는다. 그래서 프로세스 간 문맥 전환이 일어날 때, 이전 프로세스가 사용하던 데이터가 CPU에 남아있다. 그러나 새로운 프로세스의 메모리 주소 공간이 다르기 때문에 캐시 데이터는 새로운 프로세스에 대해 무효하다.  
  
새로운 프로세스의 데이터를 다시 캐시에 로드해야 되기 때문에, 초기에는 캐시 미스가 발생하며, 이로 인해 CPU가 메모리에서 데이터를 다시 읽어와야 한다.  
  
프로세스 간 문맥 전환 시, TLB도 무효화되기 때문에 새로운 프로세스에 맞는 주소 변환을 다시 로드해야 한다.  
  
 
스레드는 동일한 프로세스 내에서 실행되기 때문에 메모리 공간을 공유한다. 스레드 간 문맥 전환시 메모리 주소 공간이 동일하기 때문에, 캐시에 저장된 데이터가 유효하다. 그래서, 캐시 미스가 덜 발생하며 캐시의 내용을 다시 로드할 필요가 적다.  

동일한 주소 공간을 공유하기 때문에 TLB도 그대로 유효하지만, 여러 스레드가 캐시를 공유하면서 동시에 접근할 경우 캐시 경쟁이 발생할 수 있다.

> TLB (Translation Lookaside Buffer)    
> 컴퓨터 메모리 시스템에서 페이지 테이블을 빠르게 조회하기 위한 작은 캐시로
> 프로그램이 메모리에 접근할 때마다 메모리 주소 변환이 필요한데, 이를 빠르게
> 처리하기 위해 자주 사용된 변환 정보를 TLB에 저장해 둔다.  
> 그러면 매번 페이지 테이블을 일일이 찾아보지 않아도 되어 속도가 향상된다.

---

#### Context Switching 에서 프로세스 수행 중에 입출력 상태로 전환되어서 대기 상태로 전환 될 때, CPU의 동작
Context Switching 에서 입출력 인터럽트가 발생하게 되면 실행 상태에 있던 프로세스는 대기 상태로 전환된다.
이때, CPU 스케줄러에 의해서 해당 프로세스의 자원이 반환되고, 이후 CPU가 입출력 인터럽트의 완료를 기다리는 동안 준비 상태 큐에 있는 프로세스 중에서 스케줄링 알고리즘에 따라 실행 상태로 들어가고,
대기 상태에 있던 프로세스는 입출력 작업이 완료되게 되면 다시 준비상태 큐로 들어간다.

---

#### Context Switching 주소공간에 대한 캐시 처리
기존의 프로세스들을 메모리에 적재할 때, 순차적으로 적재를 하게 되면 단편화 문제가 발생하는데, 이를 방지하기 위해서 가상 메모리 기법이 생겼고, 가상 메모리 기법은 세그멘테이션과 페이징 기법으로 나눌 수 있다.
가상 메모리 기법으로 분할 된 메모리의 페이지들은 페이지 테이블에서 관리를 하게 되는데, 메모리에 실제 주소를 참조하기 위해서는

페이지 테이블에 한번 접근(fetch)
페이지 테이블을 기반으로 실제 메모리로 접근 (Memory Access)
와 같은 과정이 필요한데, 실행할 때마다 같은 table에 속한 메모리 주소를 찾고 다시 메인 메모리에 접근해야 하는 불필요한 일이 발생한다.
이런 메모리의 접근을 줄이기 위해서 TLB가 등장했고, TLB는 page table의 임시저장 캐시 역할을 하며, L3 캐시에 위치한다. 
이때 TLB에는 최근에 읽었던 변환될 물리 주소를 매핑해서 저장한다. 
따라서 TLB를 활용하면 한 프로세스 내의 다른 스레드 문맥 교환 시, TLB에서 invalid가 발생하지 않으면 주소 변환이 빨라져 하드웨어적으로 효율이 높아진다.
그러나 프로세스 간의 문맥 교환이 발생하면, 커널 주소 공간을 제외한 대부분의 TLB 항목이 무효화되기 때문에, 프로세스는 TLB를 다시 채워야 하고, 이는 스레드 전환보다 성능이 떨어진다.

---

### 프로세스(Process)와 쓰레드(Thread)의 관계
각 프로세스는 자원을 개별적으로 할당받기 때문에 공유하지 않는다.    
   
스레드는 CPU가 프로세스를 실행시키기 위한 최소 작업 단위로, 하나의 프로세스 안에는 한 개 이상의 스레드가 들어있다. 프로세스 안에 있는 스레드들은 프로세스의 자원을 공유한다.

####  프로세스의 스레드에 대한 정보
PCB는 프로세스의 기본 정보를 관리하는데, 각 프로세스 내의 스레드에 대한 정보를 간접적으로 관리한다.
TCP는 스레드 제어 블록으로 스레드의 상태, 레짓스터, 스택 포인터 등을 저장하는 자료구조로, 
프로세스의 여러 스레드를 개별적으로 관리한다.  
프로세스는 공유 메모리를 통해 스레드들이 동일한 주소 공간에 접근하게 하며, 스케줄러는 TCB를 참조하여 스레드의 실행 순서를 정한다.  

---

## 프로세스의 생성과 소멸
프로세스는 자신의 프로세스를 복제해 자식 프로세스를 생성할 수 있다. 
이러한 관계를 트리 구조로 표현이 가능하다.    

프로세스가 실행을 완료하면 OS에 exit() 시스템 콜을 통해 삭제를 요청한다. 사용된 자원이 반납된다.

<img width="580" alt="스크린샷 2024-11-13 오후 4 56 53" src="https://github.com/user-attachments/assets/d82b0132-254b-49ab-b6ac-1b5d500d93e9">

### 자원 공유 옵션
- 모든 자원 공유
- 자식은 부모의 일부 자원만 공유 가능
- 부모와 자식 사이의 자원 공유 X

### 자식 프로세스 생성 후, 부모 프로세스
- 자식 프로세스가 끝날 때까지 기다립니다. → waiting queue
- 자식 프로세스와 함께 동작 → 멀티 프로세싱 환경

### 자식 프로세스의 주소 공간
- 부모 프로세스와 동일한 새로운 프로세스로 부모 프로세스의 프로그램, 데이터가 완전 복사된다.
- 새로운 프로그램을 메모리에 load하고 이를 실행한다.

---
#### wait()
자식 프로세스가 종료될 때까지 현재 프로세스의 동작을 멈추는 시스템 콜 함수로,

자식 프로세스가 종료 시, 자식 프로세스 종료 시그널(SIGCHLD → Signal Child)이 발생하여 waiting queue에 있던 부모 프로세스가 ready queue로 이동한다. 
그리고 다시 실행이 가능해진다.

#### abort()
프로세스를 비정상적으로 종료시키고 코어 덤프 파일을 생성하는 시스템 콜로
부모 프로세스가 자식 프로세스를 강제로 종료시키는 경우에 사용된다ㅏ.
- 자식이 할당된 자원을 초과하여 사용하는 경우
- 자식에게 할단된 태스크가 더 이상 필요하지 않은 경우
- 부모가 종료되고, 운영체제가 부모 종료 시 자식이 계속 실행되는 것을 허용하지 않은 경우

---
#### 좀비 프로세스
자식 프로세스가 종료되었지만 부모 프로세스가 wait() 함수를 호출하지 않아
자식의 PID와 종료 상태 등의 최소한의 정보가 메모리에 남아 있는 상태로,
부모가 wait()을 호출하면 이 정보가 제거되어 자식 프로세스는 완전히 소멸한다.

#### 고아 프로세스
부모 프로세스가 먼저 종료된 후, 부모가 없는 자식 프로세스이다.    
운영체제는 이를 방지하기 위해, 부모가 종료되면 자식 프로세스의 새로운 부모로 init 프로세스(PID=1)가 설정된다.
init은 자식 프로세스가 종료될 때까지 기다린 후 wait()을 호출하여 종료 상태를 회수하고, 이를 통해 좀비 프로세스를 방지한다.
하지만 시스템 자원을 낭비하고 성능 저하를 일으킬 수 있다.

---

## Interprocess Comunication, IPC
여러 프로세스가 데이터를 교환하는 방식으로, 커널이 제공하는 IPC를 이용해 프로세스 간 통신이 이루어진다.

### Message Passing
<img width="278" alt="스크린샷 2024-11-13 오후 5 20 31" src="https://github.com/user-attachments/assets/6cebcc49-6152-4d10-9709-687a783e7f5b">
   
서로 다른 프로세스 간에 공유 자원 없이 메시지를 전달하는 IPC 방식으로, 커널을 통해 메시지를 주고받는다.
주요 연산은 **send(message)**와 **receive(message)**이며, 메시지 크기는 고정되거나 변할 수 있다.  

Communication Link는 프로세스 간 메시지를 전달하는 통로로, 직접 통신과 간접 통신이 있다.    
  
**Direct Communication 직접 통신**   
- 발신자와 수신자의 이름을 명시적으로 지정해야 하며, 한 링크는 두 프로세스만 연결된다.
- 두 프로세스 사이에는 하나의 링크만 존재한다.
- 보통 양방향 통신 가능하나, 단방향도 가능  

**Indirect Communication 간접 통신**      
- 메시지는 mailbox 또는 port를 통해 전달되며, 각 mailbox는 고유한 ID를 갖는다.
- 한 링크에 여러 프로세스가 참여할 수 있으며, 여러 링크가 두 프로세스 사이에 존재할 수 있다.
- 단방향, 양방향 통신이 가능

### Shared Memory

<img width="240" alt="스크린샷 2024-11-13 오후 5 20 26" src="https://github.com/user-attachments/assets/21aefdb3-d55e-481d-85b1-f7ba3cc71d1a">

서로 다른 프로세스들이 일부 주소 공간을 공유하게 하여, 중개자 없이 직접 메모리에 접근할 수 있도록 하는 IPC 방식  

빠른 데이터 교환이 가능하지만, 여러 프로세스가 공유 자원에 접근할 때 **동기화 문제**가 발생할 수 있다. 
프로세스가 공유 메모리 할당을 요청하면 커널이 메모리를 할당하고, 이후 모든 프로세스는 해당 메모리 영역에 접근할 수 있다.  

### Ordinary Pipe
두 프로세스를 단방향으로 연결하는 통신 방식으로, 하나는 데이터를 쓰기만 하고 다른 하나는 데이터를 읽기만 한다.
양방향 통신을 원하면 2개의 파이프가 필요하며, 부모-자식 관계에서만 사용된다.  
  
### Named Pipe
익명 파이프의 확장으로, 이름 있는 파일을 사용해 통신할 수 있어 부모 프로세스와 관련이 없는 다른 프로세스도 통신이 가능하다.  
단방향 통신이며, 양방향 송수신을 위해서는 2개의 파이프가 필요하다.  

### Socket
프로세스 간 통신의 종착점으로, 클라이언트와 서버가 IP 주소와 포트 번호를 통해 연결된다.
원격 프로세스 간 데이터 공유에 사용되며, loopback을 통해 같은 호스트 내에서도 TCP/IP를 이용해 통신할 수 있다.
