## CPU Scheduling
여러 프로그램이나 작업이 동시에 실행될 때, CPU를 각 작업에 어떻게 분배할지를 결정하는 방법으로, 운영체제가 여러 작업을 어떤 순서로 처리할지를 계획하는 일이다.
   
   
   
CPU는 실제 여러 작업을 동시에 처리하는 것이 아니라, 
빠르게 전환하면서 마치 동시에 여러 작업을 처리하는 것처럼 보이도록 한다. 
이렇게 CPU가 작업을 전환하는 방식을 **컨텍스트 스위칭(Context Switching)** 이라고 한다.  



<br><br><br>

멀티 프로세싱과 멀티 태스킹 두 차이가 뭘까?  


#### 멀티 프로세싱 (Multiprocessing):
멀티 프로세싱은 여러 개의 CPU를 사용하여 동시에 여러 프로세스를 처리하는 방식이다.
예를 들어, 2개의 CPU 코어를 가진 컴퓨터는 한 번에 2개의 프로세스를 동시에 실행할 수 있다.  
따라서 여러 프로세스를 진짜로 동시에 처리할 수 있다.


#### 멀티태스킹 (Multitasking):
멀티태스킹은 하나의 CPU에서 여러 프로세스를 빠르게 전환하면서 처리하는 방식으로,
하나의 프로세스가 실행되는 중에 CPU는 다른 프로세스를 잠시 실행시키고 다시 돌아오는 방식입니다. 
이 전환이 매우 빠르기 때문에 마치 여러 프로세스를 동시에 처리하는 것처럼 보인다.  


<br><br><br>

### CPU가 "동시에" 여러 작업을 처리하는 것처럼 보이는 이유?
CPU는 각 프로세스를 처리하는 중에 작업의 상태를 저장해두고, 
다른 프로세스를 실행한 후 돌아와 이전 상태에서 이어서 실행한다. 
   
이 작업은 굉장히 빠르게 이루어지는데, 따라서 사람의 눈에는 여러 작업이 동시에 실행되는 것처럼 보인다.
     
예를 들어, 컴퓨터가 10개의 작업을 1초 동안 처리해야 한다면, CPU가 각 작업을 0.1초씩 처리하고 다시 전환하면, 10개 작업이 1초 동안 모두 끝난 것처럼 보인다.

<br>

### 탭이 여러 개가 떠 있는 경우 속도가 느려진다 
각 탭은 별도의 프로세스로 실행되는데, 탭 하나하나가 자신의 작업을 처리하는데 그만큼의 CPU를 사용한ㄷ.  
그래서 탭이 많아지면 각각 처리해야 하기 때문에, 더 많은 시간과 자원을 소비하게 된다.   

탭은 독립적인 프로세스로 개별적으로 메모리를 차지하기 때문에 결국 전체 메모리 사용량이 증가한다.   


따라서 CPU와 메모리 자원이 부족해져 컴퓨터의 속도가 느려진다. 

<br><br><br><br><br><br><br><br><br>

## 선점과 비선점
#### 선점형 스케줄링
CPU가 현재 프로세스를 실행 중일때 스케줄러에 의해 현재 프로세스의 제어권을 다른 프로세스한테 
넘기는 스케줄링이다.   
다른 프로세스에 제어권을 선점 당하면 실행 중이던 프로세스는 Running에서 Ready 상태로 변경된다. 



#### 비선점 스케줄링
CPU가 현재 실행 중인 프로세스가 완료될 때까지 대기하는 스케줄링이다.  
현재 실행 중인 프로세스가 종료되거나, 입/출력을 위해 대기 상태로 들어가는 경우에 다른 프로세스들이 실행된다.  


<br><br>

### 프로세스의 4가지 상황에 따른 CPU 스케줄링 결정

- **한 프로세스가 Running -> Waiting 상태로 전환 될 때(입/출력 요청 등)**
- 프로세스가 Running -> Ready 상태로 전환 될 때(다른 프로세스의 인터럽트 발생)
- 프로세스가 Waiting -> READY 상태로 전환 될 때(입/출력의 종료)
- **프로세스가 종료할 때**


<br><br>

### 디스패처(Dispatcher)
스케줄러가 선택한 프로세스가 실제 CPU를 사용하게 만드는 작업을 한다.
- 문맥을 교환(Context Switching)
- 사용자 모드로 전환하여 프로세스가 실행될 수 있도록 한다.
- CPU를 실제로 선택된 프로세스에 넘긴다.  

##### 디스패처 지연?
하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는데까지 소용되는 시간을
디스패처 지연이라고 한다.  


<br><br><br><br><br><br><br><br><br>

## 스케줄링 알고리즘

### FCFS
CPU를 먼저 요청하는 프로세스가 먼저 할당 받는 스케줄링이다.   
이 방법은 평균 대기 시간이 길어질 수 있다.   
수행 시간이 긴 프로세스가 먼저 오는 경우 뒤에 온 수행시간이 짧은 프로세스들은 
오랜 시간 대기해야 한다. 따라서 평균 대기 시간이 길어지게 된다.  

FCFS는 비선점형으로, CPU가 할당 되면, 프로세스가 종료, 입/출력 전까지 CPU를 점유한다.  


<br>

### Shortest-Job-First. SJF


선입 선처리 문제를 개선하기 위한 알고리즘으로 CPU burst가 짧을수록 먼저 할당받는 비 선점형 알고리즘이다.  
하지만 실제 실행 시간 예측이 어려워 구현이 어렵다. 그리고 긴 프로세스가 계속해서 대기해야 할 수 있어 기아(starvation) 문제가 발생할 수 있다.   


<br>

### Priority Scheduling
우선순위가 높은 프로세스들에게 먼저 CPU를 할당하는 비선점형 스케줄이다. 만약 우선 순위가 같다면
FCFS에 따라 처리된다.  

이 방법도 낮은 우선순위 프로세스들이 CPU를 무한히 대기하는 경우가 발생한다.  
따라서 무한 blocking, starvation 문제가 생길 수 있다.   

해결 방안으로는 aging이 있다. 오래 대기한 프로세스들의 우선 순위를 증가시키는 기법이다.  



<br>

### Round-Robin Scheduling
작은 단위의 시간을 정의(Time Quntum)하고, 한 번에 하나의 프로세스에게 CPU를 할당하는 선점형 스케줄링이다.  
시간 할당량은 10에서 100밀리 초이다.   

   
   
#### 프로세스의 CPU 버스트 길이가 시간 할당량 보다 짧은 경우
프로세스 자신이 CPU를 자발적으로 방출
스케줄러는 준비 완료 큐에 있는 다음 프로세스로 진행함  

     
#### 프로세스의 CPU 버스트 길이가 시간 할당량 보다 긴 경우
타이머가 끝나면 운영체제에게 인터럽트를 발생시킴
문맥 교환(Context Swtich) 수행
실행하던 프로세스는 준비 완료 큐의 꼬리(tail)에 넣음


공평하게 시간을 분배하기 때문에 특정 프로세스가 독점하는 일이 없고, 시간이 다 되면 강제로 CPU를 반환한다.  
시간의 할당량이 크면, 짧은 프로세스들이 CPU를 빨리 사용하지 못해, 대기 시간이 길어지고, 시간 할당량이 작으면, 
자주 교체되어 문맥 교환 비용이 증가한다.  




<br>

### Multilevel Queue Scheduling
여러 개의 준비완료 큐를 사용하여 프로세스를 그룹화하고, 각 큐에 우선 순위를 부여하는 방식이다.  

각 큐는 서로 다른 우선순위를 가지며, 각 큐에 할당된 프로세스들은 자신의 큐 내에서만 스케줄링된다ㅏ.
우선 순위가 높은 큐에 있는 프로세스가 먼저 실행되며, 우선 순위가 높은 큐가 비어야 낮은 우선순위 큐 프로세스가 실행된다. 

각 큐마다 스케줄링 알고리즘을 가질 수 있다. 

프로세스가 한 큐에 속하면 다른 큐로 이동할 수 없고, 낮은 우선순위를 갖는 프로세스는 기아 상태에 빠질 수 있다.  



<br>

### Multilevel Feedback Queue Scheduling (이동 가능)
Multilevel Queue Scheduling를 보완하여 프로세스의 상태에 따라 여러 큐 사이를 이동할 수 있는 방식이다.  

프로세스가 할당된 시간 내 작업을 완료하지 못하면, 낮은 우선순위 큐로 이동해 더 긴 시간을 할당 받는다.  

프로세스는 높은 우선순위 큐에서 시작하여 짧은 시간을 할당 받는다. 주어진 시간 내에 완료하지 못하면 우선순위가 낮은 큐로
이동해 다음 큐의 시간 할당량에 따라 실행된다. 
시간 할당량을 초과하는 프로세스는 점점 낮은 우선순위 큐로 이동하여, 짧은 작업을 우선 처리하ㅏ고, 긴 작업이 뒤로 밀리는 방식이다.

프로세스가 동적으로 우선순위를 변경할 수 있으며, 짧은 프로세스는 높은 우선순위 큐에서 빨리 완료할 수 있어 응답시간이 빨라진다.  


<br><br><br><br><br><br><br><br>




## Thread Scheduling

#### User Level Thread
#### Kernel Level Thread
- 스케줄링하는 주체가 커널로 커널이 모든 프로세스와 스레드를 관리한다.



#### 구조

- One-To-Many : 하나의 Kernel Thread가 여러 개의 Thread를 관리한다.
- One-To-One : 한 개의 Kernel Thread가 한 개의 Thread를 관리한다.
- Many-To-Many : 여러 개의 Kernel Thread가 여러 개의 Thread를 관리한다.


### 범위
#### PCS
사용자 수준 스레드가 같은 프로세스 내부에서만 경쟁하는 방식으로 
LWP(Light Weight Process)에 대해 사용자 수준 스레드를 스케줄링하며, 프로세스 내에서만 스레드가 경쟁한다.
이 방식은 운영체제의 커널이 관여하지 않는 사용자 수준 스케줄링이다. 

#### SCS
운영체제 커널이 모든 커널 수준 스레드를 시스템 전체에서 경쟁하게 하는 방식이다.  
운영체제가 직접 커널 스레드를 스케줄링하기 때문에, 모든 프로세스의 스레드가 동일한 자원(CPU)을 놓고 경쟁한다.
커널 수준 스케줄링으로, 운영체제의 스케줄러가 CPU 할당을 관리한다.


### 왜 운영체제에서 PCS를 사용하지 않을까?
PCS는 프로세스 내부에서만 스레드 경쟁이 이루어지므로, 
다중 프로세스 환경에서 CPU를 효율적으로 사용할 수 없다. 
현대의 운영체제는 다중 코어를 최대한 활용해야 하기에 SCS 방식이 더 효율적이다.  


    
PCS는 운영체제보다는 특정 사용자 수준 스레드 라이브러리,
애플리케이션 레벨에서 쓰레드를 독립적으로 관리할 때 주로 사용된다.   
예를 들어, JVM(Java Virtual Machine) 등 일부 환경에서 내부적으로 사용자 수준 스레드를 관리할 때 PCS가 사용될 수 있다.



