정규화는 테이블을 분할하여, 데이터의 중복을 줄리고, 효율적으로 구조화하여 이상 현상을 제거하는 과정입니다.  
주 목적은 데이터의 무결성을 유지하고 데이터베이스의 성능을 높이는 것입니다.  

<br><br><br>

## 정규화를 왜 해야 되는데? 안하면 안돼?
하나의 테이블에 너무 많은 릴레이션이 있으면 데이터의 중복이 많이 생기고, 이로 인해서 이상 현상이 발생할 수 있다.  
따라서 정규화를 통해 중복을 최소화하고 데이터의 일관성을 높일 수 있다.  

데이터의 중복을 줄이면 저장 공간을 절약하고, 데이터 업데이트 시 발생할 수 있는 비일관성 문제를 방지할 수 있다ㅏ.  


<br>

### 정규화를 안하면??
동일한 정보가 여러 곳에 저장될 수 있어, 그렇게 되면 불필요하게 저장 공간이 낭비 돼.  
그리고 삽입, 삭제, 수정 이상 현상이 생길 수 있어.

그래서 정규화를 통해 적절하게 분리함으로써 데이터를 효율적으로 관리해야 해.


<br><br><br>

## 정규화 과정
각 단계를 통해서 데이터 구조의 문제를 하나씩 해결해~

#### 가장 먼저 1NF로 가자.  
각 컬럼은 하나의 값을 갖도록 테이블을 조정해야 해.  
예를 들어, 전화번호가 여러 고객 정보를 다룰 때, 한 명의 고객이 여러 개의 전화번호를 가질 수 있잖아?
이때, 각각의 전화번호를 별도의 행이나 열로 나누어 저장해야해  
따라서 다중값이 아닌 단일 값을 갖도록 바꿔야 하는게 이 단계야  
이 단계에서는 컬럼이 원자성을 갖도록, 모든 값이 독립적이어야 해.

<br>

#### 그 다음 2NF  
기본키가 여러 컬럼으로 이루어진 경우, 그 중 일부에만 종속되는 열이 있으면 이것을 분리해야 해  

학생과 수업 정보를 기록하는 경우 학생 ID와 수업 코드로 구성된 기본키가 있다고 생각해보자.  
학생 이름이 학생 ID에만 종속된다면, 이것을 별도로 분리해야 해.  

이 부분에서는 부분 종속을 제거해야 해.  

<br>
  
#### 3NF
이행적 종속을 제거하는 단계로, 컬럼이 중간 단계를 거치지 않고 기본키에 직접 종속되록 테이블을 조정하는 단계여.  

직원 ID로 부서를 알 수 있고, 부서로 위치를 알 수 있다면, 직원ID로 부서의 위치를 알 수 있어.  
이런 구조일 때, 부서와 위치 정보를 별도로 분리해서, 직원 ID만으로도 직접 위치를 알 수 있도록 해.  

  <br>
  
#### BCNF  
모든 결정자, 즉 데이터를 고유하게 식별할 수 있는 컬럼은 반드시 후보키여야 한다. 
부서별로 관리자를 지정해두는 경우 부서와 관리자 조합이 고유한 후보키 역할을 해야 한다.  
여기서는 결정자 컬럼이 유일한 키가 되어야 한다.


<br><br><br>

##  비정규화? 언제 비정규화를 해야해?
정규화를 통해 나눠진 데이터 구조를 효율성 또는 편의를 위해서 다시 조인하는 작업으로, 일부러 중복과 관계를 허용한다.  
정규화로 너무 작게 나누게 되면 데이터가 여러 테이블로 나뉘어 조인 연산이 많아지기 때문에, 비정규화를 통해 쿼리 성능을 개선할 수 있다.  

<br>

### 읽기 성능이 중요한 경우
조인 연산을 줄여 하나의 테이블에서 저장하고 조회하면 속도가 빠르다.

<br>

### 대규모 데이터에서 성능 최적화가 필요한 경우
빅데이터와 같이 데이터 양이 많고, 조인 연산이 많을 경우 비정규화를 통해 성능 병목을 줄일 수 있다.

<br>

### 중복에 의한 일관성보다 편의성을 우선시할 때
자주 변경되지 않는 데이터의 경우에는 약간의 중복을 허용하면서 조회를 편리하게 만들 수 있다.  
예를 들어, 지역 정보가 포함된 고객 정보를 따로 관리하는 대신, 주문 정보에 지역 데이터를 포함하여 중복을 허용할 수 있다.






<br><br><br>

## 정규화가 데이터베이스의 성능에 미치는 영향은 무엇인가요? 정규화와 쿼리 성능 사이의 관계는 어떻게 되나요?
정규화된 데이터베이스는 쓰기 성능에는 효율적이지만, 읽기 성능에서는 느릴 수 있다.  
   
데이터를 조회할 때는 여러 테이블을 조인해야 하는 경우가 많아지기 때문에, 쿼리 성능이 저하될 수 있다.

예를 들어, 고객 정보와 주문 정보를 별도의 테이블로 분리하여 정규화하면, 주문에 대한 모든 정보를 얻기 위해 두 테이블을 조인해야 한다.
이로 인해 조인 작업에 많은 리소스가 사용되기 때문에, 읽기 성능을 고려해야 하는 경우, 비정규화나 인덱스를 통해 성능을 유지할 수 있다.


<br><br><br>


## 비관계형 데이터베이스에서의 데이터 구조?

비관계형 데이터베이스는 많은 양의 비정형 데이터, 관계가 없는 데이터를 효율적으로 처리하도록 설계되어 있다. 
이 때문에 데이터 중복이 있을 수 있지만, 빠른 데이터 액세스와 높은 확장성이 장점인 구조이다.

비관계형 DB는 데이터 중복을 허용하면서 성능과 접근성을 최적화한다. 
예를 들어, 문서형 데이터베이스에서는 사용자와 그에 대한 모든 주문 정보가 하나의 문서에 저장될 수 있다.
관계형 DB에서와 달리 조인 없이 데이터에 접근이 가능하여, 빠른 데이터 읽기 성능을 요구하는 애플리케이션에 적합하다.

#### 종류
- 문서형: JSON과 유사하게 데이터 구조를 갖고 있으며, 계층적 데이터를 중첩하여 저장할 수 있습니다. 예: MongoDB.
- 키-값형: 키와 값을 쌍으로 저장하여 빠른 조회가 가능합니다. 예: Redis.
- 컬럼형: 특정 열 기준으로 데이터가 저장되어, 대용량의 컬럼 기반 데이터 조회에 적합합니다. 예: Cassandra.
- 그래프형: 데이터 간의 관계를 그래프로 표현하여, 복잡한 관계형 쿼리를 빠르게 수행할 수 있습니다. 예: Neo4j.

<br><br><br>

## 정규화가 필요한 실제 사례나 비즈니스 요구 사항은 무엇인가요?
정규화가 필요한 실사례는 데이터의 일관성 유지와 중복 최소화가 중요한 비즈니스 환경이다.   
고객 정보 관리, 재고 관리, 은행 시스템과 같이 중요한 데이터가 있는 경우가 해당된다.  

특히 변경이 빈번하고 여러 부서가 데이터를 공유하는 환경에서는 정규화가 매우 중요하다.

<br><br><br>
