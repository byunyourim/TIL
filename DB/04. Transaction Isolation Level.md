여러 트랜잭션이 동시에 처리될 때,  
특정 트랜잭션이 다른 트랜잭션에서 변경, 조회 중인 데이터를 볼 수 있도록 허용할지를 결정하는 것으로 
접근 허용 정도를 나타낸다.  

격리 수준이 높아질수록 동시성은 낮아지지만 데이터의 일관성은 높아진다.  

<br>

## Read Uncommitted (Level 0)
커밋되지 않은 데이터를 다른 트랜잭션이 조회할 수 있도록 허용한 수준이다.  

트랜잭션 A와 B가 동시에 실행되며 서로의 변경 사항을 볼 수 있다.
- B가 A의 중간 상태를 보고 잘못된 결정을 할 수 있다.

### Dirty Read
데이터 불일치와 일관성 문제가 발생한다.
- 트랜잭션 B가 아직 커밋되지 않은 트랜잭션 B의 데이터를 읽을 수 있다.
- A가 나중에 롤백할 수 있다.
- 그러면 B는 잘못된 데이터를 기반으로 작업을 하게 된다.













<br><br><br>

## Read Committed (Level 1)
트랜잭션의 변경 작업을 외부에서 조회할 수 없게하는 격리 수준으로 커밋이 완료된 데이터만 조회가 가능하다.  
Dirty Read문제를 해결할 수 있다.    

잔액 조회 쿼리의 경우, 쿼리가 실행될 때마다 다른 결과가 조회되는 문제가 발생할 수 있다.
  
- 중간 상태를 보지 않기 때문에 데이터의 일관성이 유지된다.
- 하지만, B가 A의 작업을 완료하는 동안 A가 B가 업데이트한 데이터를 읽을 수 없습니다.

### Non-repeatable Read
트랜잭션 B가 일관성 없는 데이터를 사용하게 되어 잘못된 결과를 초래할 수 있다.
- 트랜잭션 B가 같은 데이터를 두 번 읽었을 때,   
첫 번째 읽기 후 트랜잭션 A가 데이터를 수정하고 커밋하면 A는 두 번째 읽기에서 다른 값을 받을 수 있다.













<br><br><br>

## Repeatable Read (Level 2)
같은 트랜잭션 내에서 조회한 데이터의 값이 항상 동일함을 보장하는 격리 수준으로 Mysql은 Repeatable Read을 기본 격리 수준으로 사용한다.  

최조 트랜잭션 실행시 스냅샵을 만든 후, 이후 스냅샷의 select를 실행하여 다른 트랜잭션 데이터가 변경되더라도 조회에 대해 같은 결과를 보장한다.  

자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 커밋된 것만 볼 수 있다.  


### Phantom Read
업데이트는 방지하지만, 삽입 및 삭제는 완전히 방지하지 못한다.   
따라서, 처음 데이터를 조회 후 다시 데이터를 조회할 때 이전에 없던 데이터가 조회될 수 있다.  







<br><br><br>

## Serializable (Level 3)
트랜잭션의 읽기 작업 시에도 공유락을 획득하게 하여,
동시에 다른 트랜잭션이 같은 데이터에 접근할 수 없도록 하는 수준이다.    

데이터를 읽는 도중에 다른 트랜잭션이 INSERT를 수행할 수 없게 되어, Phantom Read 문제를 해결할 수 있다.

트랜잭션 A와 B가 순차적으로 실행되는 것처럼 보이한다.  

가장 높은 수준의 격리로 데이터의 무결성을 보장하지만, 성능 저하가 발생할 수 있다.


<br><br><br>
