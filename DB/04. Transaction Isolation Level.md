여러 트랜잭션이 동시에 처리될 때,  
특정 트랜잭션이 다른 트랜잭션에서 변경, 조회 중인 데이터를 볼 수 있도록 허용할지를 결정하는 것으로 
접근 허용 정도를 나타낸다.  

격리 수준이 높아질수록 동시성은 낮아지지만 데이터의 일관성은 높아진다.  

<br>

# Read Uncommitted (Level 0)
B 트랜잭션이 작업 중인 데이터(커밋X)를 다른 A트랜잭션이 조회할 수 있다.    

### 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽게되면?

커밋하지 않은 데이터를 다시 롤백하게 되면 다른 트랜잭션은 잘못된 데이터를 가지고 사용한 것이 된다. 
따라서 잘못된 결과가 나오게 된다.    

이 문제를 Dirty Read 라고 한다.

<br>
    
## Dirty Read

- 트랜잭션 B가 아직 커밋되지 않은 트랜잭션 B의 데이터를 읽을 수 있다.
- A가 나중에 롤백할 수 있다.
- 그러면 B는 잘못된 데이터를 기반으로 작업을 하게 되어 데이터 불일치, 정합성에 문제가 생긴다.

  













<br><br><br>


# Read Committed (Level 1)  
Dirty Read 문제를 해결하기 위해 커밋된 데이터만 조회할 수 있도록 하였다.  
   
이 단계에서는 트랜잭션의 변경 작업을 외부에서 수 없도록, 커밋이 완료된 데이터만 조회가 가능하도록 하였다.    
    
하지만, 반복적으로 읽기 작업을 수행할 때, 다른 트랜잭션의 커밋 여부에 따라 조회 결과가 달라질 수 있다.  

잔액 조회 쿼리를 생각해보자.  

쿼리가 실행될 때마다 잔액이 다르게 조회되는 문제가 발생할 수 있다.
  
- 중간 상태를 보지 않기 때문에 데이터의 일관성은 유지되지만, 하나의 트랜잭션내에서 반복적으로 조회할 때, 일관되지 않은 결과를 볼 수 있다. 

<br>

## Non-repeatable Read
- 트랜잭션 B가 같은 데이터를 두 번 읽었을 때,   
첫 번째 읽기 후 트랜잭션 A가 데이터를 수정하고 커밋하면 A는 두 번째 읽기에서 다른 값을 받을 수 있다.









<br><br><br>

# Repeatable Read (Level 2)
Level 1에서 하나의 트랜잭션 내에서 반복적으로 조회시 결과 값이 달라지는 Non-repeatable Read 문제가 있었다.   

그래서 Repeatable Read에서는 같은 트랜잭션 내에서 조회한 데이터의 값이 항상 동일함을 보장하도록 하였다.   


Mysql은 Repeatable Read을 기본 격리 수준으로 사용한다.  

  
최초로 트랜잭션을 실행할 때 스냅샵을 만들고, 이후에는 스냅샷의 select를 실행하여 다른 트랜잭션 데이터가 변경되더라도 조회에 대해 같은 결과를 보장한다.    
  
자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 커밋된 것만 볼 수 있다.    
   
이러한 방법은 하나의 트랜잭션 내에서 동일한 연산에 대해 동일한 결과를 보장한다.

<br>

## Phantom Read
하나의 트랜잭션 내에서 동일한 연산에 대해 동일한 결과를 보장하지만, 새로운 레코드의 추가는 막을 수 없다.  
  
따라서, 처음 데이터를 조회 후 다시 데이터를 조회할 때 이전에 없던 새로운 데이터가 조회될 수 있다.  

보통 MVCC가 자신보다 나중에 실행된 트랜잭션이 추가한 레코드는 무시하기 때문에 유령 읽기를 방지할 수 있다면

<br><br>

#### 이 문제는 언제 생길까?
잠금이 사용될 때 생긴다.  


<br><br>

일반적인 RDBMS를 살펴보자.  

만약, 사용자B가 먼저 `SELECT FOR UPDATE`를 이용해 쓰기 잠금을 걸면 어떻게 될까?

**`SELECT FOR UPDATE는 데이터 조회가 언두 로그가 이닌 테이블에서 수행된다.`** 따라서 테이블에서 변경이 일어나지 않도록 테이블에 잠금을 걸고 테이블에서 데이터를 조회한다.

그렇기 때문에 Phantom Read가 발생하게 된다.


하지만 Mysql의 경우 갭 락이 존재한다. 

<br><br>

### Gap Lock?
데이터베이스의 레코드가 위치한 범위(간격)에 잠금을 거는 방식이다.  

예로, 레코드 A와 B사이에 걸리면, 그 사이에 있는 새로운 레코드가 추가되는 것을 방지한다.  
이를 통해 트랜잭션이 실행되는 동안 다른 트랜잭션이 해당 범위에 영향을 주지 못하도록 하여, 일관성과 무결성을 보장한다.  

하지만 과도하게 걸게되면, 성능 저하와 데드락이 발생할 수 있다.  


- 프라이머리 키(PK) 기반으로 FOR UPDATE를 하면 갭 락이 적용되지 않음 (레코드 락만 걸림)   
- 일반 인덱스(Secondary Index) 기반 FOR UPDATE를 하면 넥스트 키 락(Next-Key Lock)이 걸리면서 갭 락이 포함됨

<br><br><br>

사용자 B가 SELECT FOR UPDATE로 데이터를 조회한 경우!!!   
    
MySQL은 id가 50인 레코드에는 레코드 락, id가 50보다 큰 범위에는 갭 락으로 넥스트 키 락을 건다.  

<br>  


따라서 사용자 A가 id가 51인 member를 insert하려고 한다면, B의 트랜잭션이 종료(커밋 or 롤백)될 때 까지 기다린 후에 insert 한다.   

이 과정에서 대기를 지나치게 오래하는 경우 락 타임아웃이 발생한다.

    
따라서 MySQL의 REAPEATABLE READ에서는 Phantom Read가 거의 발생하지 않는다.   


<br>



### MySQL에서 Phantom Read가 발생하는 거의 유일한 케이스?

사용자 B는 트랜잭션을 시작하고, 잠금없는 `SELECT 문으로 데이터를 조회`하였다.

그리고 사용자 A는 INSERT 문을 사용해 데이터를 추가하였다. 이때 잠금이 없으므로 바로 COMMIT 된다. 

하지만 사용자 B가 `SELECT FOR UPDATE로 조회를 한다면`, 언두 로그가 아닌 테이블로부터 레코드를 조회하기 때문에 Phantom Read가 발생하게 된다.

<br><br>

이러한 케이스는 거의 존재하지 않는다.  
따라서, MySQL의 REPEATABLE READ에서는 PHANTOM READ가 발생하지 않는다고 봐도 된다.   


> #### MySQL 기준
> SELECT FOR UPDATE 이후 SELECT: 갭락 때문에 팬텀리드 X  
> SELECT FOR UPDATE 이후 SELECT FOR UPDATE: 갭락 때문에 팬텀리드 X  
> SELECT 이후 SELECT: MVCC 때문에 팬텀리드 X  
> SELECT 이후 SELECT FOR UPDATE: 팬텀 리드 O  
 
 <br>

 
마지막으로   
트랜잭션 내에서 실행되는 SELECT와 트랜잭션 없이 실행되는 SELECT의 차이를 보자.  
  
REPEATABLE READ에서는 트랜잭션 번호를 바탕으로 실제 테이블 데이터와 언두 영역의 데이터 등을 비교하여 어떤 데이터를 조회할 지 판단한다.   
    
즉, 트랜잭션 안에서 실행되는 SELECT라면 항상 일관된 데이터를 조회하게 된다. 
하지만 트랜잭션 없이 실행된다면, 데이터의 정합성이 깨지는 상황이 생길 수 있다.   

  
 커밋된 데이터만을 보여주는 READ COMMITTED 수준에서는 둘의 차이가 거의 없다.
 


<br><br><br>

# Serializable (Level 3)
트랜잭션의 읽기 작업 시에도 공유락을 획득하게 하여,
동시에 다른 트랜잭션이 같은 데이터에 접근할 수 없도록 하는 수준이다.    

데이터를 읽는 도중에 다른 트랜잭션이 INSERT를 수행할 수 없게 되어, Phantom Read 문제를 해결할 수 있다.

트랜잭션 A와 B가 순차적으로 실행되는 것처럼 보이한다.  

가장 높은 수준의 격리로 데이터의 무결성을 보장하지만, 성능 저하가 발생할 수 있다.


<br><br><br>
