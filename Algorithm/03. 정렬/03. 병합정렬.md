## 병합 정렬 Merge Sort

<img width="619" alt="image" src="https://github.com/user-attachments/assets/75092f07-bf39-4ee3-8952-8f468ed0c541">

각각의 부분리스트는 정렬된 상태여야 한다.  


<br>

- 같은 값의 원소들은 정렬 과정에서 순서가 변하지 않는다.
- 정렬 과정에서 추가 적인 메모리를 사용한다. (병합 과정에서 두 하위 배열을 새로운 배열을 합치는 과정에서 발생)
- 큰 데이터 셋에 적합한 알고리즘
- 재귀적으로 배열을 분할하고 병합한다.


<br><br><br>



## 시간 복잡도
O(nlogn)
리스트의 크기가 2라면 1번, 
 O(log2n)


<img width="600" alt="image" src="https://github.com/user-attachments/assets/d429664b-b520-45c6-b070-77aa2eee693d">

1. 분할 과정에서 리스트의 크기가 1/2씩 감소한다.
2. 처음 n개의 리스트에서 분할을 진행하면 n/2크기의 서브 리스트 2개를 얻는다.
3. 이 상태에서 다시 분할하면 n/4크기의 서브 리스트 4개를 얻는다.

 
이러한 분할 연산을 모든 서브 리스트들의 크기가 1이 될 때까지 반복한다.
리스트의 크기가   
2인 경우 ->  1번,   
4인 경우 ->  2번,    
8인 경우 ->  3번 
반복 해야 크기가 1인 리스트를 얻을 수 있다.

<br>

<img width="600" alt="image" src="https://github.com/user-attachments/assets/a85eac9d-5ce5-411b-b3cd-7700491f957a">

합병 할 때는 , 각 element들을 비교하면서 진행한다.
리스트의 크기가 1인 상태일 때,   
총 n개의 리스트가 있기 때문에 n번의 비교연산을 수행하게 된다.  

  
리스트의 크기가 n/4이고 갯수가 4개라면 또 다시 n번의 비교연산을 해야 한다.
따라서, 각 depth에서 n번 비교 연산을 하게되고, 이는 O(n)의 시간 복잡도를 요구한다.


<br><br><br>

## 동작
1. 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.
2. 부분 배열을 정렬한다.
3. 부분 배열의 크기가 크면, 재귀 호출을 통해 다시 분할 정복 방법을 진행합니다.


<br><br><br>

## 구현
