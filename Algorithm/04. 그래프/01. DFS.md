## DFS(Depth First Search, 깊이 우선 탐색)
그래프 탐색 알고리즘 중 하나로, 트리나 그래프 구조에서 특정 노드부터 시작하여 깊이를 우선으로 탐색하는 방식  
  
한 노드에서 출발하여 그 노드의 모든 자식 노드를 먼저 방문하고, 자식 노드가 없거나 모두 방문한 경우에만 부모 노드로 되돌아가는 방식


<br>

## 1. 알고리즘 흐름
DFS는 재귀 호출이나 **스택**을 이용해 구현
  
깊이 우선으로 탐색하기 때문에 경로의 끝까지 계속 탐색을 진행하다가 더 이상 탐색할 수 없을 때 이전 노드로 돌아가서 다른 경로를 탐색합니다.

<img width="395" alt="image" src="https://github.com/user-attachments/assets/6c5c250c-885c-4df4-9242-12e9e13e84b7">

<img width="821" alt="image" src="https://github.com/user-attachments/assets/83524113-9b52-4611-89fe-6564c2ab25cc">

<br>

### DFS의 흐름
1. 시작 노드 설정: 탐색을 시작할 시작 노드를 선택한다.
2. 방문 노드 기록: 해당 노드를 방문한 것으로 표시한다. (보통 방문 여부를 기록하기 위해 visited 배열 사용)
3. 인접 노드 탐색: 현재 노드와 연결된 다른 노드(자식 노드)를 탐색, 자식 노드 중 방문하지 않은 노드가 있으면 그 노드를 방문한다.
4. 깊이 탐색: 방문한 노드를 기준으로 다시 그 노드의 자식 노드를 탐색하고, 더 이상 자식 노드가 없으면 부모 노드로 되돌아간다..
5. 탐색 완료: 모든 노드를 탐색할 때까지 이 과정을 반복한다.

<br><br><br>

## DFS 구현 (재귀 방식)
```java
public class DFSSample {
    static List<List<Integer>> graph = new ArrayList<>();
    static boolean[] visited;

    public static void main(String[] args) {
        int n = 5; // 노드 수
        visited = new boolean[n + 1];
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<>());
        }

        // 그래프에 엣지 추가 (양방향 그래프)
        addEdge(1, 2);
        addEdge(1, 3);
        addEdge(2, 4);
        addEdge(3, 4);
        addEdge(4, 5);

        // DFS 실행 (스택 기반)
        dfs(1); // 1번 노드에서 DFS 시작
    }

    // 엣지 추가
    static void addEdge(int u, int v) {
        graph.get(u).add(v);
        graph.get(v).add(u);
    }

    // DFS 구현 (재귀)
    static void dfs(int node) {
        // 현재 노드를 방문 처리
        visited[node] = true;
        System.out.println("Visited node: " + node);

        // 현재 노드와 연결된 다른 노드들을 재귀적으로 방문
        for (int neighbor : graph.get(node)) {
            if (!visited[neighbor]) {
                dfs(neighbor);
            }
        }
    }
}
```
## DFS의 흐름 설명
노드 1에서 탐색을 시작하고, 노드 1과 연결된 노드 2, 3 중 하나를 먼저 깊이 탐색한다.
예를 들어 노드 2를 선택한 경우, 노드 2에서 다시 그와 연결된 노드 4로 탐색을 이어간다.
노드 4에서 더 깊이 갈 수 있는 노드 5로 이동하여 계속 탐색한다.
노드 5에는 더 이상 연결된 미방문 노드가 없으므로 다시 상위 노드로 돌아간다.

<br>


## 2. 시간 복잡도
DFS는 모든 노드와 모든 간선을 한 번씩 방문  
그래프의 노드 개수를 V, 간선 개수를 E

시간 복잡도 : **O(V + E)**  
  
노드(V): 모든 노드를 한 번씩 방문.
간선(E): 모든 간선을 한 번씩 탐색.

<br>

## DFS 흐름 방식
- 재귀 또는 스택을 이용한 탐색: DFS는 재귀를 이용해 구현할 수 있으며, 재귀는 내부적으로 함수 호출 스택을 사용하여 깊이 탐색을 수행합니다. 만약 재귀를 사용하지 않는 경우에는 스택 자료 구조를 직접 사용해도 동일한 방식으로 깊이 우선 탐색을 구현할 수 있습니다.  

- 순차적 깊이 탐색: DFS는 한 경로로 깊이 들어가서 끝까지 탐색한 후에 다른 경로를 선택합니다. 그 때문에 주로 트리와 같은 구조에서 모든 노드를 탐색할 때 사용됩니다.
경로 복구: DFS는 기본적으로 끝까지 탐색한 후 뒤로 돌아가 다른 경로를 선택하기 때문에, 이를 통해 탐색한 경로를 기억하고 필요한 경우 경로를 복구할 수 있습니다.

<br>

## DFS와 BFS의 차이점
DFS는 깊이 우선 탐색으로, 한 경로를 끝까지 탐색한 후 다른 경로를 탐색합니다.
BFS는 너비 우선 탐색으로, 현재 노드와 연결된 모든 이웃 노드를 먼저 탐색한 후 다음 깊이로 넘어갑니다.  

  
#### DFS의 활용 예시:
경로 찾기: 미로 문제처럼 한 출발점에서 목적지까지의 경로를 찾는 문제에 적합합니다.
그래프에서 연결 요소 찾기: DFS는 연결된 모든 노드를 탐색하므로 연결 요소를 찾는 데 사용할 수 있습니다.
트리 구조 탐색: 깊이 우선으로 트리의 모든 노드를 방문하거나 특정 값을 탐색할 때 적합합니다.
