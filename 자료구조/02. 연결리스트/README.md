## Linked List


노드 기반의 자료구조로 각 노드는 데이터와 다음 노드를 가리키는 참조를 갖는다.  

배열과 달리 연결 리스트는 연속된 메모리 공간을 요구하지 않는다.   

요소를 추가하거나 제거할 때마다 동적으로 크기를 조절할 수 있다.   
배열과 달리 크기를 미리 지정할 필요가 없으며 필요한 만큼의 메모리를 사용한다.

<br><br><br>


## 종류
- 단일 연결 리스트
  - 각 노드는 하나의 포인터 필드를 갖고, 다음 노드를 가리킨다.
  - 마지막 노드는 다음 노드로 null을 가리킨다.
  - 한 방향으로만 탐색이 가능하다.
    <img width="670" alt="image" src="https://github.com/user-attachments/assets/6704ab05-8f63-48c3-951e-3449d5e506fa">

- 이중 연결 리스트
  - 각 노드는 두 개의 포인터 필드를 갖는다.
  - 하나는 다음 노드를 가리키고, 하나는 이전 노드를 가리킵니다.
  - 양방향 탐색이 가능하며, 노드를 삭제하거나 추가하는 과정이 더 유연하다.
<img width="677" alt="image" src="https://github.com/user-attachments/assets/24119b58-aefc-446b-a933-7bcc49dab1ff">

- 원형 연결 리스트(Circular Linked List):
  - 마지막 노드가 다시 첫 번째 노드를 가리켜 원형 구조를 이룬다.
  - 단일 연결 리스트와 이중 연결 리스트 모두 원형으로 구현할 수 있다.
  - 원형 구조를 사용하면 끝에서 다시 처음으로 돌아가는 순환적인 작업을 할 수 있다.

<br><br><br>



## 연산
연결 리스트는 요소를 삽입하거나 삭제할 때 속도가 빠르다.   
특정 위치에 요소를 삽입, 제거시 해당 위치의 참조만 변경하면된다.  
따라서 시간 복잡도가 O(1) 이다.  


리스트의 중간에 있는 요소를 제거하는 경우 제거할 노드의 이전 노드가 제거할 노드의 다음 노드를 가리키도록 참조를 변경한다.

필요할 때마다 메모리를 할당하기 때문에 배열처럼 미리 큰 메모리 공간을 할당할 필요가 없다. 따라서 메모리 효율이 높다.

요소를 추가하거나 제거할 때 다른 요소를 이동시킬 필요가 없어, 배열에서 발생하는 요소 이동으로 인한 시간 낭비가 없다.

그러나, 각 요소가 데이터와 두 개의 참조를 가지기 때문에 ArrayList에 비해 메모리 사용량이 높다.

또한 임의의 요소에 접근하는데 시간이 많이 걸린다. O(n)의 시간 복잡도를 가지며 인덱스를 기반으로 한 빠른 접근이 필요한 경우 ArrayList가 더 적합하다.

배열은 메모리 상에 연속적으로 저장되기 때문에 캐시 효율성이 높으나, LinkedList 는 각 노드가 메모리 상에 흩어져 저장되어 캐시 효율성이 떨어진다.




<br><br><br>

## 장단점
#### 장점
- 미리 크기를 설정할 필요가 없고, 데이터 추가에 따라 크기가 동적으로 변한다.
- 배열과 달리 요소의 삽입, 삭제시 다른 요소들의 이동이 없기 때문에 더 효율적이다.

#### 단점
- 각 노드가 데이터뿐 아니라 다음 노드의 주소도 저장해야 하기 때문에 메모리 사용량이 더 크다.
- 배열과 달리 연결리스트는 임의접근이 불가능하다.
- 필요한 데이터를 찾기 위해 처음부터 끝까지 순차적으로 탐색해야 하기때문에 시간이 더 소요된다.


<br><br><br>

**ArrayList와 LinkedList의 요소 추가 및 삭제 성능 차이**

- **ArrayList**
  - 요소를 끝에 추가하는 작업이 빈번한 경우 유리하다.
  - 중간에 요소를 추가, 삭제하는 경우 비효율적이다.
- **LinkedList**는 요소를 중간에 추가하거나 삭제하는 작업이 빈번한 경우에 유리합니다. 하지만 인덱스를 기반으로 요소에 접근하는 작업은 비효율적이다.

<br><br><br>



**LinkedList에서 요소를 추가할 때의 내부 동작 메커니즘**

1. **끝에 요소 추가**:  
    - LinkedList에서는 끝에 요소를 추가하는 것이 비교적 간단합니다. 이는 해당 요소의 이전 노드의 참조를 새로운 요소로 변경하고, 새로운 요소의 다음 노드를 null로 설정하여 연결하는 방식으로 이루어진다.
    - 이 동작은 상수 시간(O(1))에 이루어진다.
2. **중간에 요소 추가**:  
    - LinkedList에서 중간에 요소를 추가할 때는 해당 위치의 이전 노드를 찾은 후, 새로운 요소의 다음 노드를 이전 노드의 다음 노드로 설정하고, 이전 노드의 다음 노드를 새로운 요소로 변경한다.
    - 이 동작은 평균적으로 O(n)의 시간이 소요된다.

#### 장점:
- 중간에 요소를 추가하거나 삭제하는 작업이 배열 기반의 자료구조보다 효율적이다.
- 요소를 추가 또는 삭제할 때 배열처럼 데이터의 이동이 필요하지 않다.
    
#### 단점:
- 인덱스를 기반으로 요소에 접근하는 작업에 비효율적이다. 특정 인덱스의 요소에 접근하려면 처음부터 해당 인덱스까지 찾아가야 한다.
- 각 요소는 다음 요소의 참조를 가지고 있기 때문에 메모리 사용량이 더 많을 수 있다.


<br><br><br>

**ArrayList와 LinkedList의 탐색 속도**
- ArrayList
  - **인덱스를 기반으로** 요소에 직접 접근하기 때문에 요소에 접근이 빠르다.
  - 따라서 요소를 탐색하는 데 O(1)의 시간이 소요된다.
- LinkedList:
  - 특정 인덱스의 요소에 접근하기 위해 처음부터 해당 인덱스까지 노드를 순회한다.
  - 따라서 요소를 탐색하는 데에는 평균적으로 O(n/2)의 시간이 소요되며, 최악의 경우 O(n)의 시간이 소요된다.
  
따라서 요소의 추가 또는 삭제가 빈번한 경우에는 LinkedList를 사용하는 것이 좋지만, 요소의 탐색이 빈번한 경우 ArrayList를 사용하는 것이 효율적이다.


<br><br><br>

## 시간복잡도
- 삽입:  
  - 처음에 삽입: O(1)
  - 중간 또는 끝에 삽입: O(n) (n은 노드의 개수, 중간 삽입은 삽입할 위치를 찾는 데 시간이 소요됨)

- 삭제:  
  - 처음 삭제: O(1)
  - 중간 또는 끝에 삭제: O(n) (삭제할 노드를 찾는 시간이 필요)

- 탐색:
  - O(n) (모든 노드를 탐색해야 할 수 있습니다.)


<br><br><br> 

  

### Array와 LinkedList
Array는 인덱스로 해당 원소에 접근할 수 있다.  
  
찾고자 하는 원소의 인덱스 값을 알고 있으면 O(1)에 해당 원소로 접근할 수 있다.  
즉, RandomAccess가 가능해 속도가 빠르다.  

하지만 삽입 또는 삭제의 과정에서 각 원소들을 이동시키는 비용이 생겨, 이 경우 시간 복잡도는 O(n)이 된다.
    
이 문제점을 해결하기 위한 자료구조가 linkedlist이다.  

각각의 원소들은 자기 자신 다음에 어떤 원소인지 기억한다.  
이 부분만 그 다음 값으로 바꾸면 삽입과 삭제를 O(1)로 해결할 수 있다.  
    
하지만 LinkedList는 원하는 위치에 한 번에 접근할 수 없다.  
원하는 위치에 삽입을 하고자 하면 원하는 위치를 탐색 과정을 통해 첫번째 원소부터 전부 탐색해야 한다.
  
* Array는 검색이 빠르지만, 삽입과 삭제가 느리다.
* LinkedList는 삽입과 삭제가 빠르지만, 검색이 느리다.
