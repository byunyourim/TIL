## 배열

**동일한 타입**의 요소들을 **연속된 메모리 공간**에 저장하는 자료구조   
**고정된 크기를** 가지며 **인덱스를 통해 데이터에 접근**이 가능하다.   

인덱스는 0부터 시작한다.

새로운 값을 삽입하거나 삭제할 경우 해당 인덱스의 주변에 있는 값을 이동시키는 과정이 필요하다.  
배열의 크기는 선언시에 지정할 수 있으며, **한 번 선언하면 크기를 바꿀 수 없다.** 

변경이 필요한 경우 배열을 새로 생성하여, 기존 요소들을 복사해야 한다.  

배열의 크기를 너무 크게 설정하는 경우, 사용되지 않는 공간이 생겨 메모리 낭비가 발생할 수 있다.  

<br><br><br>

### 시간복잡도
인덱스를 통해 데이터에 접근하기 때문에 접근 속도가 빠르다.
배열의 중간에 요소를 삽입 또는 삭제하는 경우 요소를 이동시키야 하기 때문에 O(n)의 시간이 소요된다.


<br><br><br>
### 예시
```java

int[] array2 = {2, 3, 5, 6, 6}

String[] fruits = null;
fruits = new String[] { “apple”, “banana”, “melon” };

int[] array = new int[5];
for (int i = 0; i < array.length; i++) {
    array[i] = i;   
}

System.out.println(Arrays.toString(array));  // [0, 1, 2, 3, 4]
```

new 연산자로 배열을 처음 생성할 경우 배열은 자동적으로 기본값으로 초기화된다.
- int 배열인 경우 0으로 초기화
- String 배열인 경우 null로 초기화


<br><br><br>

### Array와 ArrayList의 차이점
**Array**는 **고정된 크기**와 단순한 구조로 메모리 사용과 접근 속도가 빠르다. 
생성 시 크기를 정해야 하며, 이후에는 크기를 변경할 수 없다.  
메모리에 연속적으로 할당되며 배열의 크기가 클 경우 메모리 부족 문제가 생길 수 있다.  

그리고 배열은 원시 타입과 참조 타입을 모두 저장할 수 있다. 

요소 저장 및 접근 기능만 제공된다.  
특정 타입의 요소만 저장할 수 있으며, 인덱스를 사용해 요소에 직접 접근할 수 있다.  

<br>

**ArrayList**는 내부적으로 동적 배열을 사용하여 크기를 조정한다.  
요소를 추가하거나 제거할 수 있으며 자동으로 크기를 조정한다. 
가변 크기이기 때문에, 메모리 관리가 복잡하며 자주 크기를 변경하면 성능에 영향을 줄 수 있다.

배열리스트는 객체(참조 타입)만 저장할 수 있으며, 원시 타입을 저장하려면
Integer, Double 와 같은 wrapper Class 를 사용해야 한다.

요소 추가, 제거, 검색 등 다양한 메서드를 제공한다.

<br><br><br>

### ArrayList의 크기가 초과될 때 크기 조정 방식과 초기 용량 설정
생성할 때 초기 용량을 설정할 수 있으며, 기본적으로 10으로 설정된다.  

add() 메서드를 이용하여 요소를 추가할 때, 내부 배열의 사용 공간이 증가한다.
내부 배열의 용량이 초과되는 경우 자동으로 배열의 크기가 증가한다.  

이 과정에서 더 큰 새로운 배열을 생성하고, 기존 배열의 요소를 새로운 배열로 복사한다. 
(새로운 배열의 크기는 기존 배열 크기의 1.5 또는 2 배)      
  
초기 용량을 적절히 설정하면 배열의 크기를 동적으로 늘리는 작업을 줄일 수 있다.  
배열을 늘리는 작업은 새로운 배열을 생성하고 기존 배열의 요소를 복사해야하기 때문에 비용이 많이 든다.
  
초기 용량을 너무 작게 설정하면 크기 조정 작업이 빈번하게 일어나 오버헤드가 발생할 수 있고,
너무 크게 설정하는 경우 메모리를 낭비할 수 있다.  

초기 용량을 적절하게 설정하여 성능을 최적화 하고 메모리를 효율적으로 사용할 수 있다.

