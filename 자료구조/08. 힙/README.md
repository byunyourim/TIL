특정한 순서에 따라 정렬된 요소들을 저장하는 트리 기반의 자료구조  


일반적으로 완전 이진 트리로 구성되며, 요소들 간의 우선순위를 관리하는데 적합하며, 높은 우선순위를 갖는 요소를 빠르게 조회하고 삭제할 수 있도록 한다.  

최악의 경우 O(logN)의 시간 복잡도로 삽입 및 삭제를 수행할 수 있다. 이는 정렬된 배열이나 리스트에 비해 효율적이다.  
또한 메모리 할당 및 해제를 동적으로 관리하는 데 유용하여, 메모리 사용의 효율성을 높일 수 있다.  


<br>

### 특징
1. 완전 이진 트리
  - 마지막 레벨을 제외한 레벨이 완전히 채워져 있다. 마지막 레벨은 왼쪽부터 채워져있는 형태이다.  
2. 부모-자식 관계
  - 부모 노드는 항상 자식 노드보다 우선순위가 높거나 같은 값을 갖는다.
  - 최대 힙에서는 부모 노드가 항상 자식노드보다 큰 값을 갖는다.
  - 최소 힙에서는 부모 노드가 항상 자식노드보다 작은 값을 값는다.
3. 레벨 별 정렬은 보장하나, 형제 간 정렬은 보장하지 않는다.


<br>

### 트리의 성질
- 루트 노드	: 1
- 노드 i의 부모	: i/2
- 노드 i의 왼쪽 자식	: i*2
- 노드 i의 오른쪽 자식	 : i*2 + 1


<br>

<img width="479" alt="image" src="https://github.com/user-attachments/assets/a47c9b34-ae6a-48aa-887d-23944b43d760">


<img width="514" alt="image" src="https://github.com/user-attachments/assets/60ff80c0-fa44-4927-b522-acf408f9db85">



<br>

## 삽입 삭제 과정
### 최소 힙 삽입
<img width="688" alt="image" src="https://github.com/user-attachments/assets/918408aa-a110-4822-9588-67db7a4ae736">

1. 트리의 가장 끝 위치에 데이터 삽입
2. 부모 노드와 비교하여 작은 경우 자리 교체
3. 위의 과정 반복

     
### 최소 힙 삭제
<img width="680" alt="image" src="https://github.com/user-attachments/assets/cad4863b-a031-46b7-b002-6c8e0c93e307">

1. 최상위 노드 반환하며 삭제
2. 최상위 노드에 가장 마지막 위치의 노드 위치
3. 자식노드와 비교하여 자리 교체(좌, 우 노드와 비교하여 더 작은 값과 자리 교체)

### 최대 힙 삽입
<img width="676" alt="image" src="https://github.com/user-attachments/assets/a523fc00-0385-416a-abe9-f7b3c4511374">

1. 트리의 가장 끝 위치에 데이터 삽입
2. 부모 노드와 비교하여 큰 경우 자리 교체
  
### 최대 힙 삭제
<img width="688" alt="image" src="https://github.com/user-attachments/assets/5e96eade-ac5f-42dd-a2c0-d21d10331ffd">

1. 최상위 노드 반환하며 삭제
2. 최상위 노드에 가장 마지막 위치의 노드 위치
3. 자식 노드와 비교하여 자리 교체(좌, 우 노드와 비교하여 더 큰 값과 자리 교체)

<br>

### 장점
- 특정한 순서에 따라 정렬된 상태를 유지하기 때문에 삽입과 삭제 연산이 상수 시간으로 이루어진다.(O(logN))
- 우선순위 큐와 같은 다른 추상 자료형을 구현하는 데 사용된다.
- 최대 힙인 경우 가장 큰 우선순위를 가진 요소에 빠르게 접근할 수 있다.
- 최소 힙인 경우 가장 작은 우선 순위를 가진 요소에 빠르게 접근할 수 있다.


<br>

### 단점
- 힙은 일반적으로 이진 트리의 형태를 가지며, 배열 또는 연결 리스트를 사용하여 구현된다.
- 따라서 임의 접근을 지원하지 않고, 요소에 접근하기 위해 순차적인 탐색을 수행한다.
- 따라서 특정 요소를 찾는 데 O(N)의 시간이 소요된다.
- 정렬된 상태를 유지하기 위해 삽입과 삭제 연산 시 정렬을 조정해야 한다. 이것은 오버헤드를 발생시킬 수 있다.
- 배열 또는 연결 리스트를 사용해 구현되기 때문에, 배열 기반의 힙에서는 공간을 미리 할당해야 하기 때문에 요소에 따라 적절한 크기를 선택해야 한다. 요소의 개수에 따라 추가적인 공간이 필요하다.

<br>

삽입, 삭제 연산에 있어 성능이 좋지만, 임의 접근, 정렬 유지와 관련해 한계가 있다.  

