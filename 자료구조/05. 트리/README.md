노드로 이루어진 계층적 자료구조이다.  

트리는 하나 이상의 루트 노드를 가지며, 루트노드는 0개 이상의 자식 노드를 갖는다.  

- 노드와 노드를 연결하는 간선으로 구성된다.
- 그래프오 달리 사이클이 존재할 수 없다.
- 각 노드는 다양한 자료형으로 표현이 가능하다.
- 비선형 자료구조로 계층적 관계를 표현한다.
- DAG(방향성이 있는 비순환 그래프)의 한 종류이다.
- 노드가 N개인 트리는 항상 N-1개의 간선을 갖는다.
- 루트에서 어떤 노드로 가는 경로는 유일하다.
- 

<br>

### 계층적인 구조를 저장하는 순서
1. 데이터와 연결 상태를 저장할 클래스 공간(노드)을 생성한다.  
```java
public class Node {
    Object data;
    Node left;
    Node right;
}
```
2. 각각의 노드에 값을 저장한다.
<img width="638" alt="image" src="https://github.com/user-attachments/assets/5c5a74ac-3505-4970-947d-a9c76d8fe4be">

노드의 data에 값을 저장한다.
leftNode, rightNode를 null로 초기화 한다. 

<img width="376" alt="image" src="https://github.com/user-attachments/assets/6d6964bb-3fd8-4bd6-9ca4-11c23a51ff03">


3. 노드 간 연결 상태를 정의한다.   
Node1의 leftNode : Node2     
Node1의 rightNode : Node3
<img width="596" alt="image" src="https://github.com/user-attachments/assets/3112ec3d-dfaa-471e-8c79-a5f30826622a">


<br>

### 용어
<img width="677" alt="image" src="https://github.com/user-attachments/assets/c8df8ece-7a6a-45ee-9f95-9aa5f2b1b1d7">

- 노드 : 트리를 구성하는 기본 요소로 키 값과 하위 노드에 대한 포인터를 갖는다.
- 간선 : 노드와 노드를 연결한 선
- 루트 : 트리 구조에서 최상위에 존재하는 노드(1)
- 부모노드 : 하나의 노드를 기준으로 바로 상위에 존재하는 노드로 자식 노드를 갖는다.
- 형제노드 : 같은 레벨의 노드로 같은 부모를 갖는다.
- 리프노드 : 자식노드를 갖지 않는 노드로 트리의 가장 하위에 위치한다.
- 서브트리 : 트리에서 특정 노드와 그 하위 자손으로 이루어진 부분 트리로 모든 노드는 하나의 서브트리이다.

<br>

- 노드의 크기 : 자신을 포함한 모든 자손 노드의 개수
- 노드의 깊이 : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수
- 노드의 레벨 : 트리의 특정 깊이를 가지는 노드의 집합
- 노드의 차수 : 하위트리 개숫 / 간선 수 = 각 노드가 갖는 가지 수

- 트리의 높이 : 루트 노드에서 가장 깊숙히 있는 노드의 깊이
- 트리의 차수 : 트리의 최대 차수

<img width="586" alt="image" src="https://github.com/user-attachments/assets/81ba115e-810a-49d2-ab81-96f8a4f4c5c3">


<br><br>


### 장점
- 계층 구조이다.
- 이진 탐색 트리의 경우 데이터를 정렬된 상태로 유지하기 때문에 탐색, 삽입, 삭제 연산에 대해 O(log N)의 시간 복잡도를 갖는다.
- 트리는 자기 참조적인 구조로, 특정 노드에서 서브트리 전체를 나타내거나 탐색할 수 있다. 이를 활용해 재귀 알고리즘을 구현할 수 있다.
- 정렬된 트리 구조는 범위 검색에 유리하다.

### 단점
- 불균형 트리의 경우, 삽입, 삭제 연산이 복잡할 수 있다.
- 트리의 재조정이 필요한 경우 추가 연산이 필요하다.
- 포인터로 연결된 노드 구조를 갖기 때문에 메모리 사용이 비교적 크다.
- 트리의 균형을 유지하기 위해 추가적인 포인터를 사용하는 경우 메모리 사용이 증가한다.
  

<br><br>

## 종류
#### 이진 트리 : 
- 각 노드의 차수가 2 이하인 트리
#### 이진 탐색 트리 : 
- 순서된 이진트리로 노드의 왼쪽 자식은 부모의 값보다 작은 값을 가져야하며, 노드의 오른쪽 자식은 부모의 값보다 큰 값을 가져야 한다.
- 모든 왼쪽 자식 <= n < 모든 오른쪽 자식

  
#### 균형 트리 : 
- m원 탐색 트리에서 높이 균형을 유지하는 트리이다.

  
#### 완전 이진 트리
<img width="494" alt="image" src="https://github.com/user-attachments/assets/9924a992-e68d-40d8-a31e-92f9ee9ef2ef">
- 마지막 레벨을 제외하고 모든 레벨이 완전히 채워진 트리
- 마지막 레벨은 노드가 왼쪽에서 오른쪽으로 채워져야 한다.
- 마지막 레벨 h에서 (1 ~ 2h-1)개의 노드를 가질 수 있다.
- 완전 이진 트리는 배열을 사용해 효율적으로 표현 가능하다.


#### 이진 힙
- 최소힙(Min Heap)
    - 부모노드가 자식노드보다 작다.
    - 즉, key(부모 노드) >= key(자식 노드)인 완전 이진 트리
    - 가장 큰 값은 루트 노드이다.
    - N개가 힙에 들어가 있으면 높이는 log(N)이다.

- 최대힙(Max Heap)
    - 부모노드가 자식노드보다 크다.

<br><br>

## 구현
#### 계층 적 데이터 저장
트리는 데이터를 계층 구조로 저장하는 데 사용됩니다. 
예를 들어 파일 및 폴더는 계층적 트리 형태로 저장됩니다.

#### 효율적인 검색 속도
효율적인 삽입, 삭제 및 검색을 위해 트리 구조를 사용합니다.

#### 힙(Heap)
힙도 트리로 된 자료 구조입니다.
데이터 베이스 인덱싱

데이터베이스 인덱싱을 구현하는데 트리를 사용합니다.
예) B-Tree, B+Tree, AVL-Tree..

#### Trie
문자를 저장하는 데 사용되는 특별한 종류의 트리입니다.


<br><br><br><br>

트리는 그래프의 한 종류로 인접리스트, 인접 배열로 구현할 수 있다.  





