# 싱글턴 패턴 (Singleton Pattern)  

**인스턴스를 단 하나만 생성하여 사용하는 패턴**   

<br>

클래스의 인스턴스가 오직 하나만 생성되도록 보장하는 패턴이다.  
커넥션 풀, 스레드 풀, 로그 관리, 캐시, 설정 관리 등에 사용된다.  

<br>

애플리케이션 내에서 하나의 클래스에 대해 오직 하나의 인스턴스만 생성하고, 어디서든 전역으로 접근 가능하게 하여,
시스템에서 자원을 효율적으로 관리하고, 일관성을 유지할 수 있도록 한다.  

<br>

- 인스턴스의 유일성 보장
- 효율적인 자원 관리
- 글로벌 접근 가능
- 상태 공유
- 객체 생성 제어

<br>

**하나의 인스턴스만을 생성**해야 하며, 
**getInstance() 메서드**를 통해 **모든 클라이언트에게 동일한 인스턴스를 반환**해야 한다.


<br>

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
- 기본 생성자를 private를 사용하여 생성을 불가능하게 해야 한다.
- getInstance를 통해서만 생성이 가능하다.
- getInstance는 내부적으로 생성되지 않았다면 새로 생성하고, 기존에 설정된 값이 존재한다면 기존의 인스턴스를 반환한다.
- 기본 생성자를 통해 생성할 수 없기 때문에, 외부에서 인스턴스에 접근하기 위해서는 static 타입으로 선언되어야 한다.

<br>

### 싱글턴 패턴 구현시 주의해야할 부분
1. **스레드 안정성** : 멀티스레드 환경에서 인스턴스가 하나만 생성되어야 한다.
2. **지연 초기화** : 필요한 시점에 인스턴스를 생성하는 방식으로 메모리 사용을 최적활 한다.
3. **직렬화** : 직렬화된 객체가 역직렬화될 때 새로운 인스턴스가 생성되지 않도록 한다.
4. **리플렉션 공격 방지** : 리플렉션을 통한 인스턴스 생성을 방지해야 한다.


여러 스레드가 공유되고 있는 상황에서 조건문이 동시에 두 번 돌 수 잇따.  
따라서 하나의 인스턴스가 아닌 여러 개의 인스턴스가 생성될 수 있다.


<br>

### 단점
1. **단일 책임 원칙 위반** : 클래스가 인스턴스 생성과 비즈니스 로직을 모두 관리할 경우 책임이 분산된다.
2. **테스트 어려움** : 싱글턴 인스턴스가 전역 상태를 가지므로 테스트 간의 독립성을 보장하기 어렵다.
3. **유연성 부족** : 상속이 어렵고, 다른 구현체로 쉽게 대체할 수 없다.
4. **리소스 회수 어려움** : 싱글턴 인스턴스는 애플리케이션 종료 시까지 존재하므로 리소스 회수가 어렵다.

