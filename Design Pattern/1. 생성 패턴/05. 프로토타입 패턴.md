# 프로토타입 패턴 Prototype Pattern

실제 제품을 생성하기에 앞서 테스트를 위한 샘플 제품을 만든다.
이때, 샘플 제품을 프로토타입이라고 한다.  

프로토타입 패턴은 객체 생성 비용이 많이 들고, 비슷한 객체가 이미 존재하는 경우 사용되는 생성 패턴이다.


<br><br><br>

# 구조
- **Abstract Factory** : 제품군을 생성하는 인터페이스 정의, 여러 관련 객체를 생성할 수 있는 메서드 포함
- **Concrete Factory** : 실제로 객체를 생성하는 클래스, Abstract Factory에서 정의한 메서드를 구현하고, 구체적인 제품 객체 생성
- **Abstract Product** : 각 제품에 대한 인터페이스 정의
- **Concrete Product** : 실제로 생성될 구체적인 제품 클래스, Abstract Product 구현


<br><br><br>

# 구현
자바에서 제공하는 clone 메서드를 사용하기 때문에 생성하려는 객체에 Clone을 Override한다.
반드시 생성하려는 객체의 클래스에서 clone 메서드가 정의되어야 한다.   


```java
public class Students implements Cloneable {
  private List<String> students;

  public Students() {
    empList = new ArrayList<>();
  }

  public Students(List <String> students) {
    this.students = students;
  }

  public void loadData() {
    students.add("winnie");
    students.add("jun");
    students.add("hama");
    students.add("may");
  }

  @Override
  public Object clone() throws CloneNotSupportedException {
    List<String> temp = new ArrayList<>();
    for (String str : this.students) {
      temp.add(str);
    }
    return new Students(temp);
  }
}
```

```java
// PrototypePattern.java
public class PrototypePattern {
    public static void main(String[] args) throws CloneNotSupportedException {
        Students students = new Students();
        students.loadData(); // Ann, John, Methew...

        Students students1 = (Students) students.clone();
        Students students2 = (Students) students.clone();

        List <String> list1 = students1.getStudents();
        list1.add("Peter");

        List < String > list2 = students2.getStudents();
        list2.remove("John");

        System.out.println("students: " + students.getStudents());
        System.out.println("students1: " + list1.getStudents());
        System.out.println("students2: " + list2.getStudents());
    }
}
```

<br><br><br>

# 장점
- **구체적인 클래스와의 의존성 제거** : 클라이언트는 구체적인 제품 클래스를 알 필요가 없다.
- **일관성 유지** : 같은 제품군의 객체들을 생성하여, 제품들 간의 일관성을 유지할 수 있다.
- **확장성** : 새로운 제품군이 추가되더라도 기존 클라이언트 코드를 수정하지 않고 새로운 팩토리를 추가하는 것만으로 확장이 가능하다.


<br><br><br>


# 단점
- **복잡성 증가** : 클래스와 인터페이스 수가 많아져 코드가 복잡해질 수 잇따.
- **유연성 제한** : 특정 제품군에 속하는 제품들만 조합해서 사용할 수 있기 때문에, 다른 제품군의 객체들과 조합이 어렵다.


<br><br><br>

제품군이 늘어나고, 다양한 플랫폼, 구성에서 인터페이스를 통해 객체를 다룰 때 유용하다.










